<style>
/* --- 基础布局样式 --- */
.media-evaluation-box {
    padding: 60px 0 85px 0;
    position: relative;
    z-index: 1;
    overflow: hidden;
}

.media-evaluation-box .container {
    margin-bottom: 70px;
}

/* 跑马灯容器 - 限制宽度，隐藏溢出 */
.media-evaluation-box .media-evaluation-marquee {
    position: relative;
    /* 在 PC 端，我们只展示需要滚动的区域 */
}

/* 列表容器 - 启用 Flex 布局 */
.media-evaluation-box .media-evaluation-list {
    display: flex;
    padding: 20px 0;
    will-change: transform; /* 性能优化 */
}

/* 列表项样式 */
.media-evaluation-box .media-evaluation-item {
    width: 390px;
    margin-right: 15px;
    padding: 45px 32px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: flex-end;
    flex-shrink: 0;
    transition: transform 0.4s ease, box-shadow 0.4s ease;
    border-radius: 20px;
    background: #F8F8F8;
    position: relative;
    z-index: 1;
}

/* Hover 效果 */
.media-evaluation-box .media-evaluation-item:hover {
    transform: translateY(-12px);
    box-shadow: 0 12px 28px rgba(55, 27, 11, 0.15);
    transition-delay: 0s;
}

.media-evaluation-box .media-evaluation-txt-top {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    position: relative;
    width: 100%;
}

.media-evaluation-box .media-evaluation-txt {
    font-size: 18px;
    color: #000;
    line-height: 1.3;
    font-weight: bold;
}

.media-evaluation-box .media-evaluation-logo {
    display: block;
    max-width: 60%;
    margin-top: 50px;
    max-height: 70px;
    height: auto;
    width: auto;
}

.media-evaluation-box .sub-text {
    color: #3F3636;
    font-size: 20px;
    line-height: 1.2;
    text-align: center;
    margin-top: 20px;
}

.media-evaluation-box .hover-svg {
    position: absolute;
    width: 50px;
    height: auto;
    top: 46%;
    left: 35%;
    display: none;
    z-index: 1;
}

/* --- 进度条容器样式 --- */
.media-evaluation-box .media-evaluation-scrollbar-container {
    width: calc(100% - 30px); /* 居中并留白 */
    margin: 30px auto 0;
    height: 6px;
    background: #E0E0E0;
    border-radius: 3px;
    overflow: hidden;
    display: none; /* 默认隐藏，仅在移动端显示 */
}

/* 进度条滑块样式 */
.media-evaluation-box .media-evaluation-scrollbar-thumb {
    height: 100%;
    background: #3F3633; /* 滑块颜色 */
    border-radius: 3px;
    width: 30%; /* 初始宽度，JS 会计算实际宽度 */
    cursor: grab;
    will-change: transform; /* 性能优化 */
}

/* --- 桌面端 (PC) 样式 (> 991px) --- */
@media (min-width: 992px) {
    .media-evaluation-box .media-evaluation-item:hover {
        cursor: url(https://cdn.shopify.com/s/files/1/0740/5882/6015/files/900f9d08c855c9a85f7f5a75ea3287cd.svg), pointer;
    }
}

/* --- 移动端样式 (<= 991px) --- */
@media (max-width: 991px) {
    .media-evaluation-box {
        padding: 50px 0;
    }
    
    .media-evaluation-box .container {
        margin-bottom: 30px;
    }

    /* 移动端列表项宽度和圆角 */
    .media-evaluation-box .media-evaluation-item {
        width: 300px; /* 进一步减小宽度以适应小屏幕 */
        border-radius: 10px;
        margin-right: 12px;
    }

    .media-evaluation-box .sub-text {
        font-size: 14px;
        margin-top: 10px;
    }

    /* 移动端显示进度条 */
    .media-evaluation-box .media-evaluation-scrollbar-container {
        display: block; 
    }

    .media-evaluation-box .hover-svg {
        width: 40px;
        top: auto;
        bottom: 30px;
        left: 32px;
        display: block;
    }
}
</style>
<section class="section-box{% if section.settings.custom_class != blank %} {{ section.settings.custom_class }}{% endif %}">
    <div class="media-evaluation-box">
        {%- if section.settings.title != blank -%}
        <div class="container">
            <div class="title-diy to-top">{{ section.settings.title }}</div>
            {%- if section.settings.text != blank -%}
            <div class="sub-text to-top">{{ section.settings.text }}</div>
            {%- endif -%}
        </div>
        {%- endif -%}

        <div class="media-evaluation-marquee marquee-box">
            <div class="media-evaluation-list marquee-box-list">
                {%- for block in section.blocks -%}
                {% assign link_title = block.settings.text | escape | default: 'View item' %}
                <a href="{{ block.settings.link }}" 
                   class="media-evaluation-item marquee-box-item to-top" 
                   style="transition-delay: 0.{{ forloop.index }}s"
                   title="{{ link_title }}">
                    <div class="media-evaluation-txt-top">
                        <div class="media-evaluation-txt">{{ block.settings.text }}</div>
                    </div>
                    
                    <img loading="lazy" 
                         class="media-evaluation-logo" 
                         width="{{ block.settings.image.width }}" 
                         height="{{ block.settings.image.height }}" 
                         {% render 'image-attributes' , image: block.settings.image %} 
                         alt="{{ block.settings.image.alt | escape }}">

                    <svg class="hover-svg" width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="30" cy="30" r="29.5" fill="white" stroke="#E1E1E1"/>
                        <g clip-path="url(#clip0_6908_1903)">
                            <path d="M41.4961 20.8487C41.6127 20.9877 41.6769 21.1688 41.6666 21.357L40.8743 36.3495L39.4133 36.2725L40.1167 22.9613L18.9851 40.6928C18.4659 40.074 18.5467 39.1504 19.1655 38.6311L40.4395 20.7801C40.6513 20.6023 40.947 20.5358 41.205 20.6383C41.3215 20.6838 41.4199 20.7579 41.4961 20.8487Z" fill="#190A0A"/>
                            <path d="M38.6743 19.8674C38.6028 20.6724 37.8932 21.2679 37.0891 21.1975L25.9692 20.2257L26.0968 18.7681L38.6732 19.8683L38.6743 19.8674Z" fill="#190A0A"/>
                        </g>
                        <defs>
                            <clipPath id="clip0_6908_1903">
                                <rect width="30" height="22.9683" fill="white" transform="translate(11.1274 31.3286) rotate(-40)"/>
                            </clipPath>
                        </defs>
                    </svg>
                </a>
                {%- endfor -%}
            </div>
        </div>

        <div class="media-evaluation-scrollbar-container">
            <div class="media-evaluation-scrollbar-thumb"></div>
        </div>

    </div>
</section>
<script>
/**
 * 参考代码的 enableDragDetection，简化触摸/鼠标事件处理
 * @param {HTMLElement} element - 要监听拖动的元素
 * @param {function} onDragLeft - 向左拖动时触发的回调，参数为距离
 * @param {function} onDragRight - 向右拖动时触发的回调，参数为距离
 * @param {function} onTouchEnd - 拖动结束时触发的回调
 */
function enableDragDetection(element, onDragLeft, onDragRight, onTouchEnd) {
    let startX = 0, startY = 0, isDragging = false, isMobile = false;
    let deltaX = 0; // 用于存储拖动位移

    const start = (x, y, mobile) => { 
        startX=x; 
        startY=y; 
        isDragging=true; 
        isMobile=mobile; 
        deltaX = 0; // 重置位移
    };
    
    const move = (x, y, event) => {
        if(!isDragging) return;

        const currentDeltaX = x - startX;
        const currentDeltaY = y - startY;
        
        // 如果是触摸事件且垂直移动为主，则忽略
        if(isMobile && Math.abs(currentDeltaY) > Math.abs(currentDeltaX) * 2) {
             // 允许垂直滚动
             return;
        }

        // 阻止默认行为（仅在进行水平拖动时尝试阻止）
        if (event && event.cancelable && isMobile) {
            event.preventDefault(); 
        }

        // 核心逻辑：计算自上次 move 以来发生的位移
        const moveDistance = currentDeltaX - deltaX;
        
        if (moveDistance > 0) {
            onDragRight?.(moveDistance);
        } else if (moveDistance < 0) {
            onDragLeft?.(Math.abs(moveDistance));
        }

        deltaX = currentDeltaX; // 更新总位移
        startX = x; startY = y; // 更新起始点为当前点（用于下次 move 的相对计算）
    };
    
    const end = () => { onTouchEnd?.(isMobile); isDragging=false; };

    // --- 绑定事件 ---
    element.addEventListener('touchstart', e => start(e.touches[0].clientX, e.touches[0].clientY, true), { passive: true });
    element.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY, e), { passive: false }); // 确保 touchmove 可以阻止默认行为
    element.addEventListener('touchend', end);
    element.addEventListener('mousedown', e => { 
        e.preventDefault(); // 阻止鼠标拖动默认行为 
        start(e.clientX, e.clientY, false); 
    });
    // 鼠标事件监听绑定到 document，防止快速拖动时丢失事件
    document.addEventListener('mousemove', e => move(e.clientX, e.clientY));
    document.addEventListener('mouseup', end);
    document.addEventListener('contextmenu', e => e.preventDefault());
}

/**
 * 跑马灯主函数
 */
function marqueeFn(elName) {
    const content = document.querySelector("." + elName);
    const ul = content?.querySelector(".marquee-box-list");
    const thumb = content?.querySelector(".media-evaluation-scrollbar-thumb");
    const scrollbarContainer = content?.querySelector(".media-evaluation-scrollbar-container");

    if (!content || !ul) return;

    const IS_MOBILE = window.matchMedia("(max-width: 991px)").matches;
    const SPEED = 1; 
    let left = 0;
    let timer = null; // 用于 PC 自动滚动的 timer

    // --- 宽度计算和设置 (通用) ---
    let totalContentWidth = 0;
    let viewportWidth = content.clientWidth;
    let originalItemCount = ul.children.length; 
    
    function setupWidths(isCloned = false) {
        // 列表项之间间距为 15px
        totalContentWidth = Array.from(ul.children).reduce((sum, item) => {
             const style = getComputedStyle(item);
             return sum + item.offsetWidth + parseFloat(style.marginRight);
        }, 0);
        
        // 只有在非克隆状态下，才减去最后一个列表项右侧多余的 15px 间距，以确保内容正好铺满
        if (!isCloned && ul.children.length > 0) {
             totalContentWidth += 15; // 补回最后一个项目的 margin-right
             totalContentWidth -= parseFloat(getComputedStyle(ul.lastElementChild).marginRight || 0);
        }

        ul.style.width = totalContentWidth + "px";
        viewportWidth = content.clientWidth;
    }


    // --- 进度条相关计算 (移动端) ---
    let scrollRange = 0; 
    let thumbRange = 0;  
    
    function setupScrollbar() {
        if (!thumb || !scrollbarContainer) return;
        
        scrollRange = totalContentWidth - viewportWidth;
        
        if (scrollRange <= 0) {
            scrollbarContainer.style.display = 'none';
            return;
        }

        scrollbarContainer.style.display = 'block';

        let thumbWidth = (viewportWidth / totalContentWidth) * scrollbarContainer.clientWidth;
        thumbWidth = Math.max(thumbWidth, 50); // 最小宽度
        thumb.style.width = thumbWidth + "px";
        
        thumbRange = scrollbarContainer.clientWidth - thumbWidth;
    }

    // --- 更新列表和进度条位置 (通用) ---
    function updatePosition(newLeft) {
        // 限制左移范围 (0 到 -scrollRange)
        left = Math.min(0, Math.max(-scrollRange, newLeft));
        
        ul.style.transform = `translateX(${left}px)`;

        // 同步进度条
        if (thumb && scrollRange > 0) {
            const scrollPercent = Math.abs(left) / scrollRange;
            const thumbLeft = scrollPercent * thumbRange;
            thumb.style.transform = `translateX(${thumbLeft}px)`;
        }
    }


    // --- PC 自动滚动函数 ---
    function run() {
        const clonedWidth = totalContentWidth / 3; // 假设内容被克隆了 3 份
        if(left < -clonedWidth) {
            left += clonedWidth;
        }
        
        left -= SPEED;
        ul.style.transform = `translateX(${left}px)`;
    }

    // --- 初始化和启动 ---

    if (IS_MOBILE) {
        // --- 移动端（手动拖动 + 进度条） ---
        
        // 确保只有原始项目
        while (ul.children.length > originalItemCount) {
             ul.removeChild(ul.lastChild);
        }
        
        setupWidths(false);
        setupScrollbar();

        // 拖动回调函数 (移动端使用 updatePosition 限制范围)
        const onDragCallback = (distance, isRight) => {
             const newLeft = isRight ? left + distance : left - distance;
             updatePosition(newLeft); 
        };

        // 绑定列表拖动事件
        enableDragDetection(ul,
            (distance) => onDragCallback(distance, false), // onDragLeft
            (distance) => onDragCallback(distance, true),  // onDragRight
            () => {} // 拖动结束
        );
        
        // 绑定进度条拖动事件
        if (thumb) {
            enableDragDetection(thumb,
                (distance) => { // onDragLeft
                    if (scrollRange <= 0) return;
                    let currentThumbX = parseFloat(thumb.style.transform.replace('translateX(', '').replace('px)', '')) || 0;
                    let newThumbX = Math.min(thumbRange, Math.max(0, currentThumbX - distance));
                    const scrollPercent = newThumbX / thumbRange;
                    updatePosition(-scrollPercent * scrollRange);
                },
                (distance) => { // onDragRight
                    if (scrollRange <= 0) return;
                    let currentThumbX = parseFloat(thumb.style.transform.replace('translateX(', '').replace('px)', '')) || 0;
                    let newThumbX = Math.min(thumbRange, Math.max(0, currentThumbX + distance));
                    const scrollPercent = newThumbX / thumbRange;
                    updatePosition(-scrollPercent * scrollRange);
                },
                () => {}
            );
        }

    } else {
        // --- PC 端（自动滚动） ---
        
        // 1. 克隆内容以实现无限滚动 (克隆 3 份)
        ul.innerHTML += ul.innerHTML; 
        ul.innerHTML += ul.innerHTML; 
        
        setupWidths(true); // 告知 setupWidths 正在处理克隆内容
        
        // 2. 启动自动滚动
        timer = setInterval(run, 10);
        content.onmouseover = ()=>clearInterval(timer);
        content.onmouseout = ()=>timer=setInterval(run,10);
        
        // 3. 拖动回调函数 (PC 端，拖动时需要暂停自动滚动)
        const onDragCallbackPC = (distance, isRight) => {
             clearInterval(timer);
             if (isRight) {
                 left += distance;
             } else {
                 left -= distance;
             }
             ul.style.transform = `translateX(${left}px)`; 
        };

        // 4. 绑定拖动事件
        enableDragDetection(ul,
            (distance) => onDragCallbackPC(distance, false), // onDragLeft
            (distance) => onDragCallbackPC(distance, true),  // onDragRight
            () => { timer=setInterval(run,10); } // 拖动结束，恢复自动滚动
        );

        // 5. 绑定 Intersection Observer
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    if (!timer) timer = setInterval(run, 10);
                } else {
                    clearInterval(timer);
                    timer = null;
                }
            });
        });
        observer.observe(content);
    }
}

// 启动
document.addEventListener('DOMContentLoaded', () => {
    marqueeFn('marquee-box');
});
</script>
{% schema %}
{
"name": "media-evaluation-icon-new",
"blocks": [
  {
    "name": "item",
    "type": "item",
    "settings": [
      {
        "type": "image_picker",
        "id": "image",
        "label": "Image"
      },
      {
        "type": "text",
        "id": "text",
        "label": "Text"
      },
      {
        "type": "url",
        "id": "link",
        "label": "链接"
      }
    ]
  }
],
  "settings": [
    {
      "type": "text",
      "id": "custom_class",
      "label": "Custom Class"
    },
    {
      "type": "text",
      "id": "title",
      "label": "Title"
    },
    {
      "type": "text",
      "id": "text",
      "label": "Text"
    }
  ],
  "presets": [
  {
    "name": "media-evaluation-icon-new",
    "blocks": []
  }
]
}
{% endschema %}